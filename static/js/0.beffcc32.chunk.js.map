{"version":3,"sources":["../../src/ui/Auth/components/Form.tsx","../../src/ui/Auth/components/internal/Label.tsx","../../src/ui/Auth/components/internal/Input.tsx","../../src/ui/Auth/components/EmailInput.tsx","../../src/ui/Auth/components/PasswordInput.tsx","../../src/ui/Auth/components/HeaderText.tsx","../../src/ui/Auth/components/internal/TextButton.tsx","../../src/ui/Auth/components/SecondaryButton.tsx","../../src/ui/Auth/components/SubmitButton.tsx","../../src/ui/Auth/components/Spacer.tsx","../../node_modules/react-hook-form/dist/index.esm.js"],"names":["Form","styled","props","display","justifyContent","minWidth","width","padding","boxShadow","borderRadius","flexDirection","fontFamily","margin","position","top","left","right","bottom","React","Label","TextFieldRoot","maxWidth","height","TextField","background","border","Bar","placeholder","id","htmlFor","label","autoComplete","type","required","HeaderText","fontSize","fontWeight","letterSpacing","marginBlockStart","marginBlockEnd","marginInlineStart","marginInlineEnd","marginTop","TextButton","cursor","color","whiteSpace","SecondaryButton","SubmitButtonRoot","SubmitButton","verticalAlign","textAlign","textOverflow","overflow","outline","boxSizing","style","isCheckBoxInput","element","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","Date","getNodeParentName","name","substring","search","isNameInFieldArray","names","some","current","compact","filter","Boolean","isUndefined","val","undefined","get","obj","path","defaultValue","result","split","reduce","key","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","omit","source","copy","Object","assign","displayName","getProxyFormState","isProxyEnabled","formState","readFormStateRef","localReadFormStateRef","isRoot","Proxy","prop","isEmptyObject","keys","length","shouldRenderFormState","formStateData","find","convertToArrayPayload","isWeb","window","HTMLElement","document","appendErrors","validateAllFieldCriteria","errors","message","types","isKey","test","stringToPath","input","replace","set","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","field","_f","ref","focus","refs","getFieldsValues","fieldsRef","output","disabled","every","isPrimitive","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","deepMerge","target","targetValue","sourceValue","_a","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","setFieldArrayDirtyFields","slice","isString","isBoolean","unset","previousObjRef","updatePath","childObject","baseGet","k","objectRef","currentPaths","currentPathsLength","item","data","getFields","fieldsRefs","currentFields","isFileInput","isMultipleSelect","isRadioInput","defaultResult","isValid","validResult","getCheckboxValue","options","option","checked","map","attributes","getFieldValueAs","valueAsNumber","valueAsDate","setValueAs","NaN","defaultReturn","getRadioValue","previous","getFieldValue","files","selected","hasValidation","mounted","min","max","maxLength","minLength","pattern","validate","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","isFunction","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","a","inputValue","mount","error","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","maxOutput","minOutput","valueDate","exceedMin","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateRef","validateError","validationResult","entries","validateFunction","validateResult","getValidationModes","mode","isOnSubmit","isHTMLElement","isRadioOrCheckboxFunction","Subscription","this","tearDowns","tearDown","push","teardown","Subscriber","observer","subscription","closed","add","next","Subject","observers","subscriber","isWindowUndefined","useForm","reValidateMode","resolver","context","shouldFocusError","shouldUnregister","criteriaMode","fieldsNamesRef","Set","formStateSubjectRef","unregisterFieldsNamesRef","watchSubjectRef","controllerSubjectRef","fieldArraySubjectRef","fieldArrayDefaultValuesRef","inFieldArrayActionRef","watchFieldsRef","isMountedRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isWatchAllRef","contextRef","resolverRef","fieldArrayNamesRef","validationMode","isValidateAllFieldCriteria","isDirty","isValidating","submitCount","touchedFields","isSubmitting","isSubmitSuccessful","updateFormState","formStateRef","getIsValid","shouldRenderBaseOnError","shouldRender","state","isWatched","previousError","updatedFormState","setFieldValue","rawValue","shouldRegister","register","forEach","radioRef","selectRef","includes","checkboxRef","shouldDirty","updateAndGetDirtyState","shouldValidate","trigger","getIsDirty","formValues","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","currentNames","validateForm","fieldError","fieldNames","schemaResult","Promise","all","fieldName","shouldFocus","setInternalValues","inputKey","has","isFieldWatched","updateValidAndValue","isWithinRefCallback","defaultChecked","then","setValue","isFieldArray","isReset","getValues","handleChange","inputType","shouldSkipValidation","previousFormIsValid","parentNodeName","currentError","updateIsValid","previousIsValid","clearErrors","inputName","setError","watchInternal","isGlobal","isArrayNames","fieldValues","watch","subscribe","info","unregister","delete","keepIsValid","keepError","keepValue","keepDirty","keepTouched","keepDefaultValue","registerFieldRef","contains","onChange","onBlur","shouldUnmount","handleSubmit","onValid","onInvalid","e","preventDefault","persist","hasNoPromiseError","resetFromState","keepErrors","keepIsSubmitted","keepDefaultValues","keepSubmitCount","registerAbsentFields","FileList","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","setFocus","formStateSubscription","useFieldArraySubscription","unsubscribe","isLiveInDom","control"],"mappings":"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","file":"static/js/0.beffcc32.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\n\nconst Form = styled.form(props => ({\n    display: \"flex\",\n    justifyContent: \"center\",\n    minWidth: 300,\n    width: 380,\n    padding: '33px 55px',\n    boxShadow: '0 5px 10px 0 rgb(0 0 0 / 10%)',\n    borderRadius: 10,\n    flexDirection: 'column',\n    fontFamily: \"inherit\",\n    margin: '6% auto 50px',\n    '@media (max-width: 520px)': {\n        margin: '0px !important',\n        position: 'fixed !important',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        width: 'initial !important'\n    },\n    ...(props.theme.form ? { ...props.theme.form } : {})\n}))\n\nexport default function (props: React.FormHTMLAttributes<HTMLFormElement>) {\n    return (\n        <Form {...props}>{props.children}</Form>\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst Label = styled.label(props => ({\n    display: \"none\",\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldLabel ? { ...props.theme.textFieldLabel } : {})\n}))\n\nexport default function (props: React.LabelHTMLAttributes<HTMLLabelElement>) {\n    return (<Label {...props} />)\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport styled from 'styled-components';\nimport Label from './Label';\n\nconst TextFieldRoot = styled.div(props => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    padding: 0,\n    height: 46,\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldRoot ? { ...props.theme.textFieldRoot } : {})\n}))\n\nconst TextField = styled.input(props => ({\n    display: \"block\",\n    width: '100%',\n    background: '0 0',\n    border: 'none',\n    fontFamily: \"inherit\",\n    ...(props.theme.textField ? { ...props.theme.textField } : {})\n}))\n\nconst Bar = styled.div(props => props.theme.textFieldBar ? { ...props.theme.textFieldBar } : {})\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function (props: ITextField) {\n    return (\n        <TextFieldRoot>\n            <TextField placeholder=\"&nbsp;\" {...props} {...props.register()} id={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')} />\n            <Bar />\n            <Label htmlFor={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')}>{props.label}</Label>\n        </TextFieldRoot>\n    )\n}\n","import React, { forwardRef } from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Email\" autoComplete=\"email\" {...props} type=\"email\" required />\n    )\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    register(): UseFormRegisterReturn;\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Password\" {...props} type=\"password\" required />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst HeaderText = styled.h1(props => ({\n    fontFamily: \"inherit\",\n    fontSize: 24,\n    fontWeight: 500,\n    letterSpacing: -.2,\n    marginBlockStart: '0.67em',\n    marginBlockEnd: '0.67em',\n    marginInlineStart: 0,\n    marginInlineEnd: 0,\n    marginTop: '16px !important',\n    ...(props.theme.headerText ? { ...props.theme.headerText } : {})\n}))\n\nexport default function (props: React.HTMLAttributes<HTMLHeadingElement>) {\n    return (\n        <HeaderText {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst TextButton = styled.button(props => ({\n    cursor: \"pointer\",\n    color: '#635bff',\n    whiteSpace: 'nowrap',\n    fontWeight: 500,\n    fontSize: 14,\n    margin: 0,\n    background: 'none',\n    border: 'none',\n    ...(props.theme.textButton ? { ...props.theme.textButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <TextButton {...props} type=\"button\" />\n    )\n}\n","import React from 'react';\nimport TextButton from './internal/TextButton';\nimport styled from 'styled-components';\n\nconst SecondaryButton = styled(TextButton)(props => ({\n    margin: '15px',\n    ...(props.theme.secondaryButton ? { ...props.theme.secondaryButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SecondaryButton {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst SubmitButtonRoot = styled.div(props => props.theme.submitButtonRoot ? props.theme.submitButtonRoot : {});\n\nconst SubmitButton = styled.button(props => ({\n    position: 'relative',\n    border: \"none\",\n    verticalAlign: \"middle\",\n    textAlign: \"center\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n    outline: \"none\",\n    cursor: \"pointer\",\n    boxSizing: 'border-box',\n    ...(props.theme.submitButton ? { ...props.theme.submitButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SubmitButtonRoot>\n            <SubmitButton type=\"submit\" {...props} />\n        </SubmitButtonRoot>\n    )\n}\n","import React from 'react';\n\ninterface ISpacer {\n    size?: \"xlarge\" | \"large\" | \"medium\" | \"small\"\n}\n\nexport default function (props: ISpacer) {\n    switch (props.size) {\n        case \"xlarge\":\n            return <div style={{ height: 64 }} />   \n        case \"large\":\n            return <div style={{ height: 58 }} />            \n        case \"small\":\n            return <div style={{ height: 16 }} />\n        default:\n            return <div style={{ height: 37 }} />\n    }\n}\n","import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n        Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n            (isRoot ? VALIDATION_MODE.all : true)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nfunction useFormState(props) {\r\n    const { control, name } = props || {};\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = control || methods.control;\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const [formState, updateFormState] = React.useState(formStateRef.current);\r\n    const readFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    React.useEffect(() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState)),\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, fieldArrayNamesRef, controllerSubjectRef, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) || isFieldArray\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const field = get(fieldsRef.current, name);\r\n    field._f.value = value;\r\n    React.useEffect(() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const shouldUnmountField = shouldUnmount || shouldUnregister;\r\n            if (isFieldArray\r\n                ? shouldUnmountField && !inFieldArrayActionRef.current\r\n                : shouldUnmountField) {\r\n                unregister(name);\r\n            }\r\n            else if (get(fieldsRef.current, name)) {\r\n                get(fieldsRef.current, name)._f.mount = false;\r\n            }\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm && ref(elm),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field && !isNullOrUndefined(output)) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f && _f.ref\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            current &&\r\n                getFieldsValues({\r\n                    current,\r\n                }, output[name]);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!React.isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = React.useRef('');\r\n    const isMountedRef = React.useRef(false);\r\n    const { isWatchAllRef, watchFieldsRef, getIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, unregister, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const [fields, setFields] = React.useState(mapIds(get(fieldsRef.current, name) && isMountedRef.current\r\n        ? get(getFieldsValues(fieldsRef), name)\r\n        : get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => convertToArrayPayload(index).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        inFieldArrayActionRef.current = true;\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value: isPrimitive(value) ? value : Object.assign({}, value),\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    React.useEffect(() => {\r\n        inFieldArrayActionRef.current = false;\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            formValues: getFieldsValues(fieldsRef),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => isString(key) && key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        isMountedRef.current = true;\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            (shouldUnmount || shouldUnregister) &&\r\n                unregister(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: React.useCallback(swap, [name]),\r\n        move: React.useCallback(move, [name]),\r\n        prepend: React.useCallback(prepend$1, [name]),\r\n        append: React.useCallback(append$1, [name]),\r\n        remove: React.useCallback(remove, [name]),\r\n        insert: React.useCallback(insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, mount, }, }, validateAllFieldCriteria) => {\r\n    if (!mount) {\r\n        return {};\r\n    }\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister, criteriaMode, } = {}) {\r\n    const fieldsRef = React.useRef({});\r\n    const fieldsNamesRef = React.useRef(new Set());\r\n    const formStateSubjectRef = React.useRef(new Subject());\r\n    const unregisterFieldsNamesRef = React.useRef(new Set());\r\n    const watchSubjectRef = React.useRef(new Subject());\r\n    const controllerSubjectRef = React.useRef(new Subject());\r\n    const fieldArraySubjectRef = React.useRef(new Subject());\r\n    const fieldArrayDefaultValuesRef = React.useRef({});\r\n    const inFieldArrayActionRef = React.useRef(false);\r\n    const watchFieldsRef = React.useRef(new Set());\r\n    const isMountedRef = React.useRef(false);\r\n    const fieldsWithValidationRef = React.useRef({});\r\n    const validFieldsRef = React.useRef({});\r\n    const defaultValuesRef = React.useRef(defaultValues);\r\n    const isWatchAllRef = React.useRef(false);\r\n    const contextRef = React.useRef(context);\r\n    const resolverRef = React.useRef(resolver);\r\n    const fieldArrayNamesRef = React.useRef(new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, updateFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = React.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = React.useRef(formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => {\r\n        formStateRef.current.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n        return formStateRef.current.isValid;\r\n    };\r\n    const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            (get(fieldsWithValidationRef.current, name) || resolverRef.current) &&\r\n                set(validFieldsRef.current, name, true);\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldRender ||\r\n            isWatched ||\r\n            (error ? !deepEqual(previousError, error, true) : previousError) ||\r\n            !isEmptyObject(state) ||\r\n            (readFormStateRef.current.isValid &&\r\n                formStateRef.current.isValid !==\r\n                    (resolverRef.current ? !!isValid : getIsValid()))) &&\r\n            !isNullOrUndefined(shouldRender)) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors, name });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                    ? ''\r\n                    : rawValue;\r\n                _f.value = getFieldValueAs(rawValue, _f);\r\n                if (isRadioInput(_f.ref)) {\r\n                    (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n                }\r\n                else if (isFileInput(_f.ref) && !isString(value)) {\r\n                    _f.ref.files = value;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n                }\r\n                else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                    _f.refs.length > 1\r\n                        ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                            ? !!value.find((data) => data === checkboxRef.value)\r\n                            : value === checkboxRef.value))\r\n                        : (_f.refs[0].checked = !!value);\r\n                }\r\n                else {\r\n                    _f.ref.value = value;\r\n                }\r\n                if (shouldRender) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, name, rawValue);\r\n                    controllerSubjectRef.current.next({\r\n                        values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                        name,\r\n                    });\r\n                }\r\n                options.shouldDirty && updateAndGetDirtyState(name, value);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n            else {\r\n                field._f = {\r\n                    ref: {\r\n                        name,\r\n                        value: rawValue,\r\n                    },\r\n                    value: rawValue,\r\n                };\r\n            }\r\n        }\r\n    }, []);\r\n    const getIsDirty = React.useCallback((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n                name,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = React.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = React.useCallback(async (name, options = {}) => {\r\n        const fieldNames = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : convertToArrayPayload(name);\r\n        let isValid;\r\n        let schemaResult = {};\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            schemaResult = await executeSchemaOrResolverValidation(fieldNames, isUndefined(name)\r\n                ? undefined\r\n                : fieldNames);\r\n            isValid = fieldNames.every((name) => !get(schemaResult, name));\r\n        }\r\n        else {\r\n            if (isUndefined(name)) {\r\n                await validateForm(fieldsRef.current);\r\n                isValid = isEmptyObject(formStateRef.current.errors);\r\n            }\r\n            else {\r\n                isValid = (await Promise.all(fieldNames\r\n                    .filter((fieldName) => get(fieldsRef.current, fieldName))\r\n                    .map(async (fieldName) => await executeValidation(fieldName, null)))).every(Boolean);\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: formStateRef.current.errors, isValidating: false, isValid: resolverRef.current\r\n                ? isEmptyObject(schemaResult)\r\n                : getIsValid() }));\r\n        if (!isValid && options.shouldFocus) {\r\n            focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldNames);\r\n        }\r\n        return isValid;\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        isFieldArray || !isPrimitive(inputValue) || (field && !field._f)\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const defaultValue = isUndefined(field._f.value)\r\n            ? get(defaultValuesRef.current, name)\r\n            : field._f.value;\r\n        if (field && !isUndefined(defaultValue)) {\r\n            if (ref && ref.defaultChecked) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n            else if (!isNameInFieldArray(fieldArrayNamesRef.current, name)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n            else {\r\n                field._f.value = defaultValue;\r\n            }\r\n        }\r\n        else {\r\n            field._f.value = getFieldValue(field);\r\n        }\r\n        if ((!isUndefined(defaultValue) || isWithinRefCallback) &&\r\n            hasValidation(options, field._f.mount) &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid !== getIsValid() &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    name,\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        ((field && !field._f) || isFieldArray) && !isNullOrUndefined(value)\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, formValues: getValues() });\r\n    };\r\n    const handleChange = React.useCallback(async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !resolverRef.current &&\r\n                !get(formStateRef.current.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        formValues: getValues(),\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? { name } : Object.assign(Object.assign({}, state), { name })));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    formValues: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = React.useCallback(async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(formStateRef.current.errors, inputName))\r\n            : (formStateRef.current.errors = {});\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            name,\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = formValues || isMountedRef.current\r\n            ? Object.assign(Object.assign({}, defaultValuesRef.current), (formValues || getFieldsValues(fieldsRef))) : isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : isArrayNames\r\n                ? defaultValue\r\n                : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? convertToArrayPayload(name)\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(defaultValuesRef.current, inputName);\r\n                watchSubjectRef.current.next({\r\n                    name: inputName,\r\n                    formValues: getValues(),\r\n                });\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n        !options.keepIsValid && updateIsValid();\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        register(name, options);\r\n        let field = get(fieldsRef.current, name);\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n            (isRadioOrCheckbox &&\r\n                Array.isArray(field._f.refs) &&\r\n                compact(field._f.refs).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(fieldsRef.current, name, field);\r\n        const defaultValue = updateValidAndValue(name, options, ref, true);\r\n        if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n            ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n            : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n            get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n        }\r\n    };\r\n    const register = React.useCallback((name, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        hasValidation(options, true) &&\r\n            set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        !field && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(fieldsRef.current, name, {});\r\n                        const shouldUnmount = shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                            // If initial state of field element is disabled,\r\n                            // value is not set on first \"register\"\r\n                            // re-sync the value in when it switched to enabled\r\n                            if (isUndefined(field._f.value)) {\r\n                                field._f.value = field._f.ref.value;\r\n                            }\r\n                        }\r\n                        if (isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n                            ? shouldUnmount && !inFieldArrayActionRef.current\r\n                            : shouldUnmount) {\r\n                            unregisterFieldsNamesRef.current.add(name);\r\n                        }\r\n                    }\r\n                },\r\n            };\r\n    }, []);\r\n    const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = getFieldsValues(fieldsRef);\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = React.useCallback(({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepDefaultValues, keepIsValid, keepSubmitCount, }, values) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : keepDefaultValues\r\n                    ? deepEqual(values, defaultValuesRef.current)\r\n                    : false,\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !!updateIsValid(values),\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const registerAbsentFields = (value, name = '') => {\r\n        const field = get(fieldsRef.current, name);\r\n        if (!field || (field && !field._f)) {\r\n            if (!field &&\r\n                (isPrimitive(value) ||\r\n                    (isWeb && (value instanceof FileList || value instanceof Date)))) {\r\n                set(fieldsRef.current, name, {\r\n                    _f: {\r\n                        ref: { name, value },\r\n                        value,\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            if (Array.isArray(value) || isObject(value)) {\r\n                if (name && !get(fieldsRef.current, name)) {\r\n                    set(fieldsRef.current, name, Array.isArray(value) ? [] : {});\r\n                }\r\n                for (const key in value) {\r\n                    registerAbsentFields(value[key], name + (name ? '.' : '') + key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of fieldsNamesRef.current) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                formValues: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            !shouldUnregister &&\r\n            registerAbsentFields(Object.assign({}, updatedValues));\r\n        resetFromState(keepStateOptions, values);\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    React.useEffect(() => {\r\n        !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    updateFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    React.useEffect(() => {\r\n        const isLiveInDom = (ref) => !isHTMLElement(ref) || !document.contains(ref);\r\n        isMountedRef.current = true;\r\n        for (const name of unregisterFieldsNamesRef.current) {\r\n            const field = get(fieldsRef.current, name);\r\n            field &&\r\n                (field._f.refs\r\n                    ? field._f.refs.every(isLiveInDom)\r\n                    : isLiveInDom(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        unregisterFieldsNamesRef.current = new Set();\r\n    });\r\n    return {\r\n        control: React.useMemo(() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            inFieldArrayActionRef,\r\n            watchFieldsRef,\r\n            getIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            unregister,\r\n            shouldUnmount: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: React.useCallback(watch, []),\r\n        setValue: React.useCallback(setValue, [setInternalValues]),\r\n        getValues: React.useCallback(getValues, []),\r\n        reset: React.useCallback(reset, []),\r\n        clearErrors: React.useCallback(clearErrors, []),\r\n        unregister: React.useCallback(unregister, []),\r\n        setError: React.useCallback(setError, []),\r\n        setFocus: React.useCallback(setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, formValues }) => (!nameRef.current ||\r\n                !inputName ||\r\n                convertToArrayPayload(nameRef.current).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(watchInternal(nameRef.current, defaultValue, false, formValues)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}